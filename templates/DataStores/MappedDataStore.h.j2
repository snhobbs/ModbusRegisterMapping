{# Jinja Template #}
/*
 * Copyright {{ timestamp.year }} ElectroOptical Innovations, LLC
 * {{ fname }}
 * Autogenerated file: {{ timestamp.isoformat() }}
 */

#pragma once

#include <Modbus/MappedRegisterDataStore.h>
#include <Modbus/DataStore.h>
#include <algorithm>
#include <array>
#include <cstdint>

namespace {{ namespace }} {
  struct MemoryMap {
    {%- for entry in entries %}
      {%- if(entry.length > 1) %}
      {{ entry.dtype_ctype }} {{ entry.name }}[{{ entry.length }}];
      {%- else %}
      {{ entry.dtype_ctype }} {{ entry.name }};
      {%- endif %}
    {%- endfor %}
  };

  enum class MemoryMapEntryIdentifier {
    {%- for entry in entries %}
    {{ entry.name }} ,
    {%- endfor %}
    unknown
  };

class DataMap {
  MemoryMap data_bank_{};
  static const constexpr std::size_t map_entry_count_ = {{ entries | length }};
  bool new_data_ = false;
  using MapEntry = Modbus::MemoryMapEntry<MemoryMapEntryIdentifier>;
  
  static const constexpr std::array<MapEntry, map_entry_count_> memory_entries_ {
    {%- for entry in entries %}
    MapEntry{MemoryMapEntryIdentifier::{{ entry.name }}, offsetof(MemoryMap, {{ entry.name }}), sizeof(MemoryMap::{{ entry.name }})},
    {%- endfor %}
  };

 private:
  static constexpr std::size_t GetMemoryMapEntryIndex(std::size_t address) {
    for (std::size_t i = 0; i < memory_entries_.size(); i++) {
      if (address*sizeof(uint16_t) <= memory_entries_[i].offset) {
        return i;
      }
    }
    return 0;
  }
  const MemoryMap& GetDataBank(void) const {
    return data_bank_;
  }
  MemoryMap& GetDataBank(void) {
    return data_bank_;
  }
  
 public:
  bool IsNewData(void) const { return new_data_; } 
  void SetNewData(bool value) { new_data_ = value; } 
  void SetField(MemoryMapEntryIdentifier identifier, const ArrayView<const uint8_t>& data_view) {
    SetNewData(true);
    switch (identifier) {
      case(MemoryMapEntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      {%- for entry in entries %}
      case(MemoryMapEntryIdentifier::{{ entry.name }}) : {
      {% if entry.dtype.name in ['int8_t', 'uint8_t', 'kString'] %}
      {% if entry.length > 1 %}
        for (std::size_t i = 0; i < std::min(sizeof(data_bank_.{{ entry.name }}), data_view.size()); i++) {
          data_bank_.{{ entry.name }}[i] = data_view.at(i);
        }
      {% else %}
          data_bank_.{{ entry.name }} = data_view[0];
      {% endif %}

      {% else %}
        const auto value = Utilities::Make_MSB_IntegerTypeFromArray<{{ entry.dtype_ctype }}, uint8_t>(data_view.data(), data_view.size());
        data_bank_.{{ entry.name }} = value;
      {% endif %}
        break;
      }
      {%- endfor %}
      default:
        break;
    }
  }

  void GetField(MemoryMapEntryIdentifier identifier, ArrayView<uint8_t>* data_view) const {
    switch (identifier) {
      case(MemoryMapEntryIdentifier::unknown): {
        // Ignore this case, should be scrubed
        break;
      }
      {%- for entry in entries %}
      case(MemoryMapEntryIdentifier::{{ entry.name }}) : {
      {% if entry.dtype.name in ['int8_t', 'uint8_t', 'kString'] %}
      {% if entry.length > 1 %}
        for (std::size_t i = 0; i < std::min(sizeof(data_bank_.{{ entry.name }}), data_view->size()); i++) {
          data_view->at(i) = data_bank_.{{ entry.name }}[i];
        }
      {% else %}
          data_view->at(0) = data_bank_.{{ entry.name }};
      {% endif %}
      {% else %}
        const auto value = data_bank_.{{ entry.name }};
        const auto array = Utilities::MakeMSBU8Array<{{ entry.dtype_ctype }}>(value);
        for (std::size_t i = 0; i < std::min(array.size(), data_view->size()); i++) {
          data_view->at(i) = array.at(i);
        }
      {% endif %}
        break;
      }
      {%- endfor %}
      default:
        break;
    }
  }

  {%- for entry in entries %}
  {%- if entry.length > 1 %}
  ArrayView<const {{ entry.dtype_ctype }}> get_{{ entry.name }}(void) const {
    return ArrayView<const {{ entry.dtype_ctype }}>{ {{ entry.length }}, GetDataBank().{{ entry.name }} };
  }
  void set_{{ entry.name }}(const {{ entry.dtype_ctype }} *const value, std::size_t length) {
    for (std::size_t i = 0; i < length; i++) {
      GetDataBank().{{ entry.name }}[i] = value[i];
    }
  }
  {%- else %}
  {{ entry.dtype_ctype }} get_{{ entry.name }}(void) const {
    return GetDataBank().{{ entry.name }};
  }
  void set_{{ entry.name }}({{ entry.dtype_ctype }} value) {
    GetDataBank().{{ entry.name }} = value;
  }
  {%- endif %}
  {%- endfor %}

 public:
  static std::size_t size(void) {
    return sizeof(MemoryMap);
  }
  static MemoryMapEntryIdentifier GetIdentifierFromAddress(std::size_t address) {
    const auto& entry = memory_entries_.at(GetMemoryMapEntryIndex(address));
    if (entry.offset != address*sizeof(uint16_t)) {
      return MemoryMapEntryIdentifier::unknown;
    }
    return entry.identifier;
  }
  static constexpr bool ReadLocationValid(std::size_t address, std::size_t count) {
    return WriteLocationValid(address, count);
  }
  static constexpr bool WriteLocationValid(std::size_t address, std::size_t count) {
    const auto& entry = memory_entries_.at(GetMemoryMapEntryIndex(address));
    return (address*sizeof(uint16_t) == entry.offset) && (entry.size == count*sizeof(uint16_t));
  }
  template<typename T>
  void SetFieldFromAddress(std::size_t address, const T& data_view) {
    const auto identifier = GetIdentifierFromAddress(address);
    SetField(identifier, data_view);
  }
  void GetFieldFromAddress(std::size_t address, ArrayView<uint8_t>* data_view) const {
    const auto identifier = GetIdentifierFromAddress(address);
    GetField(identifier, data_view);
  }

  DataMap(void) {}
  };  // class DataMap
}  // namespace {{namespace}}

