{%- for include in includes %}
#include "{{ include }}"
{%- endfor %}
#include <Modbus/Utilities.h>
#include <Modbus/MappedRegisterDataStore.h>
#include <modbus.h>
#include <cassert>
#include <iostream>
#include <array>
#include <string>
#include <cstdio>
#include <cerrno>
#include <cstdint>
#include <unistd.h>
#include <cstring>
#include <string>
#include <vector>


template<typename T>
void PrintArray(const T& t) {
  for (auto pt : t) {
    std::cout << static_cast<int>(pt) << ",";
  }
  std::cout << std::endl;
}


struct ModbusEntry {
  std::string name;
  std::string dtype;
  std::string type;
  size_t length;
  size_t address;
  size_t registers;

  ModbusEntry(std::string name, std::string dtype, std::string type, size_t length, size_t address, size_t registers):
  name_{name}, dtype_{dtype}, type_{type}, length_{length}, address_{address}, registers_{registers}):
  {}
};

static const constexpr std::vector<ModbusEntry> entries {
  {% for entry in entries %}
  {{entry["name"], entry["data type"], entry["type"], entry["length"], entry["address", entry["register count"]]}}
  {% endfor %}
};

template<typename T>
int ReadPrint(modbus_t* ctx, const int kAddressStart, int cnt) {
  T reg{};
  int rc = modbus_read_registers(ctx, kAddressStart, cnt, reg.data());
  if(rc == -1) {
    fprintf(stderr, "Read Error %s\n", modbus_strerror(errno));
    return -1;
  }
  assert(rc == cnt);
  PrintArray(reg);
  return 0;
}

inline int ConnectRtu(modbus_t** ctx, const char* dev_name, const std::size_t baudrate = 9600) {
  *ctx = modbus_new_rtu(dev_name, baudrate, 'N', 8, 1);
  return 0;
}

int main(int argc, char** argv) {
  HoldingRegisters hregs_struct;
  HoldingRegistersWrapper hregs_wrapper{&hregs_struct};
  Modbus::MappedRegisterDataStore<HoldingRegistersWrapper> hregs{&hregs_wrapper};
  InputRegisters inregs_struct;
  InputRegistersWrapper inregs_wrapper{&inregs_struct};
  Modbus::MappedRegisterDataStore<InputRegistersWrapper> inregs{&inregs_wrapper};

  const char* dev_name = nullptr;
  uint8_t slave_address = 246;
  if(argc > 1) {
    dev_name = argv[1];
    if(argc > 2) {
      slave_address = atoi(argv[2]);
    }
  }
  printf("Device: %s\n", dev_name);
  printf("Address: %u\n", slave_address);
  modbus_t *ctx = nullptr;
  //  ConnectRtu(&ctx, DemoData::master_name);
  ConnectRtu(&ctx, dev_name);

  //Set the Modbus address of the remote slave
  modbus_set_slave(ctx, slave_address);//DemoData::slave_address);

  if (modbus_connect(ctx) == -1) {
    fprintf(stderr, "Connection failed: %s\n", modbus_strerror(errno));
    modbus_free(ctx);
    return -1;
  }
  modbus_set_debug(ctx, slave_address);


#ifdef MODBUS_TIMEVAL
  struct timeval response_timeout;
  modbus_get_response_timeout(ctx, &response_timeout);

  response_timeout.tv_sec = 1;
  response_timeout.tv_usec = 0;
  modbus_set_response_timeout(ctx, &response_timeout);
  modbus_set_byte_timeout(ctx, &response_timeout);
#else
  modbus_set_response_timeout(ctx, 1, 0);
  modbus_set_byte_timeout(ctx, 1, 0);
#endif
  
  printf("Connection Successful\n");
  
  for (auto& entry : entries) {
    std::cout << "Reading " << entry.name << std::endl;
    std::vector<uint16_t> read_buffer{};
    read_buffer.reserve(entry.registers);

    //sleep(1);
    if (entry.type == "input register") {
      modbus_read_input_registers(ctx, entry.address, entry.registers, read_buffer.data());  
      inregs.SetFieldFromAddress(entry.address, ArrayView<const uint8_t>(u8array.size(), u8array.data()));
      const auto value = inregs_wrapper.get_{{ entry['name'] }}();
      std::cout << value << std::endl;
    }
    else if (entry.type == "holding register") {
      std::vector<uint16_t> write_buffer{};
      write_buffer.reserve(entry.registers);
      for (size_t i=0; i<entry.registers; i++) {
        write_buffer[i] = 0xffff - i;
      }
      modbus_write_registers(ctx, entry.address, entry.registers, write_buffer.data());
      sleep(1);

      std::vector<uint8_t> u8array{};
      u8array.reserve(entry.registers*sizeof(uint16_t));
      Modbus::MakeRegistersToBytes(read_buffer, ArrayView<uint8_t>(u8array.size(), u8array.data()));
    }
    ReadPrint<decltype(read_buffer)>(ctx, entry.address, entry.registers);
  }

  modbus_close(ctx);
  modbus_free(ctx);
}
